# Why TDD?


---

### Testing
### Modularity
### Fewer Bugs
### Less Confusion

---

# Modularity is key!

---

# Why Modular?

- Easy to think about
- Easy to change
- Easy to fix

---

# What makes a good module?

---

# Cohesive

- It's members work to do one thing
- and just one thing
- Makes sense!

---

# Decoupled

- Collaborators are connected by interface
- So they're interchangable
- Keep things loose!

---

# The alternative is pain

- Tight coupling of objects
- More difficult to understand
- Hard to change
- Hard to fix
- Easy to break!

---

# Test First Design

What TDD was originally called. ...I wish we'd stuck with that.

---

# Start with modules

---

# Decoupled by Design

- Only test the subject

---

# Cohesive by Design

---

Your tests are a living document

---

It has to make sense!

---

Good tests grow the code and enforce clean design, and cohesive purpose.

---

Dependencies / Collaborative objects?

---

# Test Doubles

---

Mocks, Stubs, Fakes, Spies

---

# Mocks grow up!

They spawn subjects they were pretending to be!

---

# Only test what you own

---

# Wrap difficult dependencies

---

# Tell don't ask

Works well for machines that operate on protocols

(don't do this with people tho!)

---

When we fake objects we don't have to worry about a whole range of problems.

(... neither does our **subject under test**)

---

Turns out we neved needed to worry about those problems when objects
are decoupled

---

# Questions?

---

![](RGR2.jpg)

---

# Thank you!
