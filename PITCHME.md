# Why TDD?

---

![](RGR.jpg)

---

### Testing
### Modularity
### Fewer Bugs
### Less Confusion

---

# Modularity is key!

---

# Why Modular?

- Easy to think about
- Easy to change
- Easy to fix

---

# What makes a good module?

---

# Cohesive

- It's members work to do one thing
- and just one thing
- Makes sense!

---

# Decoupled

- Collaborators are connected by interface
- So they're interchangable
- Keep things loose!

---

The alternative is pain

---

Tight coupling of objects

---

More difficult to understand

--- 

Hard to change

---

Hard to fix

---

Bugs show up more often

---

# Test First Design

What TDD was originally called. ...I wish we'd stuck with that.

---

# Starts with modules

---

# Decoupled by Design

---

Only test the subject

---

# Cohesive by Design

---

Your spec has to make sense!

---

(otherwise how can you pass it?)

---

Good tests grow the code and enforce clean design

---

# Dependencies / Collaborative objects?

---

The unit test shouldn't test what the object doesn't do directly.

---

# Tell don't ask

---

Verify that calls are made, not what happens after.

You shouldn't need to know what a dependency does with a message.

---

(to get that decoupling goodness)

---

# Test Doubles

---

Mocks, Stubs, Fakes, Spies

---

# Mocks can evolve

They can turn into the objects they were pretending to be!

---

(adhereing to interfaces / protocols)

---

# Only test what you own

Wrap difficult third party dependencies

---

page left intentionally blank

---

A little more about testing...

---

# Testing Pyramid

---

![](PYRAMID.jpg)

---

# Integration tests

Cover collaboration of objects and services (fakes)

---

# e2e

Test the full stack

---

This is all just one way to approach the subject of TDD.

---

There's a lot of ways to look at testing and TDD.

---

So feed your head!

---

# Questions?

---

![](RGR2.jpg)

---

# Thank you!
